/**
 * ----------------------------------------------------------------------------
 * content of widget-dataGrid-mobile.js  
 * ----------------------------------------------------------------------------
 */

/**
 * @brief			DataGrid, part of WAF/Widgets
 * @details			Displays data from an entity, uses Model-View-Controller architecture (MVC). DataProvider is
 * a model, GridView is a view, and GridController functions as controller.
 *
 *
 *
 * @author			rudolfpsenicnik
 * @date			February 2009
 * @version			1.0
 *
 * @include			copyright.txt
 */
WAF.classes.DataGrid = function(options)
{

	// Private
	this._private = {
		globals: {
			processingRequests: 0,
			itemCount: 0,
			//dataStore: null,
			columnsDefinition: null,
			sortColumn: null,
			sortOrder: null
		},
		functions: {
			parent: this,

			checkColumnsDefinition: function(colNames, colAttributes) // old code, should not be used anymore
			{

				if (typeof colNames == "undefined" || typeof colAttributes == "undefined")
				{
					return null;
				}

				var colNames = colNames.slice();
				var colAttributes = colAttributes.slice();
                var width = 130;
				for (var i = 0; i < colNames.length; i++)
				{

                    // fix a bug
                    if (typeof options !== 'undefined') {
                        if (typeof options.colWidth !== 'undefined') {
                          width = options.colWidth[i] ? parseInt(options.colWidth[i]) : 130;
                        }
                    }

					if (typeof colNames[i] === 'string')
					{
						colNames[i] = {
							sourceAttID: colAttributes[i],
							colID: colAttributes[i].split(".").join("_"),
							title: colNames[i],
							width: width,
							sortable: true,
							readOnly: false
						}
					}
					else
					{
						if (colAttributes[i].colID === undefined)
						{
							colAttributes[i].colID = colAttributes[i].sourceAttID;
						}
						if (colAttributes[i].title === undefined)
						{
							colAttributes[i].title = colAttributes[i].sourceAttID;
						}
						if (colAttributes[i].width === undefined)
						{
							colAttributes[i].width = 130;
						}
						if (colAttributes[i].sortable === undefined)
						{
							colAttributes[i].sortable = true;
						}
						if (colAttributes[i].readOnly === undefined)
						{
							colAttributes[i].readOnly = false;
						}

					}
				}

				return colNames;
			},

			// initializes the grid with passed options
			initWithOptions: function(options)
			{

				var dataGrid = options.dataGrid;				
				dataGrid.dataSource = options.dataSource;
				dataGrid.subscriberID = options.subscriberID;
				dataGrid.isIncluded = options.included || false;
				if (options.inDesign)
					dataGrid.isInDesign = true;
				else
					dataGrid.isInDesign = false;
					
				if (options.columns == null)
				{
					// then we need to call the old code
					options.columns = this.checkColumnsDefinition(options.colNames ? options.colNames : options.columns, options.colAttributes ? options.colAttributes : options.columns);
	
					if (options.columns == null && !dataGrid.isInDesign)
					{
						options.columns = this.checkColumnsDefinition(dataSource.getAttributeNames())
					}
				}
				else
				{
					// now the 'data-column' generated by the studio contains a JSON represenation of the columns, so it is already almost fully good
					
					var cols = options.columns;
					var nbcol = cols.length;
					for (var i = 0; i < nbcol; i++)
					{
						var col = cols[i];
						if (col.format != null && typeof(col.format) == 'string')
						{
							col.format = { format : col.format };
						}
						if (col.colID == null && col.sourceAttID != null)
						{
							col.colID = col.sourceAttID.split(".").join("_");
						}
						if (col.sortable == null)
							col.sortable = true;
					}
				}
					
				/*
				if (options.columns == null || options.columns.length == 0)
				{
					options.columns = [{ coldID:"col1" }];
				}
				*/


				//WAF.utils.debug.console.log('[DataGrid] WAF.classes.DataGrid._private.functions.initWithOptions called');

				//dataGrid._private.globals.dataStore = options.dataStore;
				
				var gridViewOptions = {
					cacheSize: options.cacheSize,
					columns: options.columns,
					rowHeight: options.rowHeight,
					cls: options.cls
				};

				dataGrid._private.globals.columnsDefinition = options.columns;

				// create grid at specified node
				if (!!options.parentNodeId)
				{
					gridViewOptions.createInNode = $('#' + options.parentNodeId);

				}
				else
					if (!!options.parentNode)
				{
					gridViewOptions.createInNode = $('#' + options.parentNode);


				}
				else
				{
					return false;
				}

				// init the grid
				dataGrid.gridController.gridView.initWithOptions(gridViewOptions);

				dataGrid.sortColumn = null;
				/*
				if (!dataGrid.isInDesign && options.dataStore.options.orderby != undefined)
				{
					if (options.dataStore.options.orderby !== "")
					{
						var sortColumnName = options.dataStore.options.orderby.split(" ")[0];

						for (var i = 0; i < dataGrid._private.globals.columnsDefinition.length; i++)
						{
							if (dataGrid._private.globals.columnsDefinition[i].sourceAttID === sortColumnName)
							{
								dataGrid.sortColumn = i;
							}
						}
					}
				}
				*/
				
				if (dataGrid.isInDesign)
					dataGrid.sortOrder = null;
				else
				{
					dataGrid.sortOrder = null;
					//dataGrid.sortOrder = (options.dataStore.options.orderby != undefined) ? (options.dataStore.options.orderby !== "") ? (options.dataStore.options.orderby.split(" ")[1] != undefined) ? options.dataStore.options.orderby.split(" ")[1] : null : null : null;

					/*
					dataGrid._private.globals.dataStore.options.onGetEntityCollection = function()
					{
						if (dataGrid.sortColumn != null)
						{
							dataGrid.gridController.gridView.setSortIndicator(dataGrid.sortColumn, dataGrid.sortOrder);
							if (dataGrid.dataSource != null)
							{
								dataGrid.dataSource.setEntityCollection(dataGrid._private.globals.dataStore, dataGrid.subscriberID);
							}
						}

						dataGrid.redraw();
					}
					*/

					// get data
					// dataGrid._private.functions.queryEntityCollection({ dataGrid : dataGrid, query : options.query,customUrl : options.cutomUrl });

					if (dataGrid.sortColumn != null)
					{
						dataGrid.gridController.gridView.setSortIndicator(dataGrid.sortColumn, dataGrid.sortOrder);
					}
				}
				// try to display data if already available
				dataGrid.redraw();
			}

			/* vieux code
			  
			
			// run a entity set query, which gives us number of entities and result which we use to get entities
			queryEntityCollection: function(options)
			{

				var dataGrid = options.dataGrid;

				dataGrid._private.globals.entityCollection = dataGrid._private.globals.dataClass.query(options.query, {
					pageSize: dataGrid.gridController.gridView.getPageSize() ? dataGrid.gridController.gridView.getPageSize() : 1, // BUG? 0 returns all
					//pageSize: dataGrid.gridController.gridView.getVisibleRowCount() ? dataGrid.gridController.gridView.getVisibleRowCount() + 2 * dataGrid.gridController.gridView._private.globals.cacheSizeInRows : 1, // BUG? 0 returns all
					//pageSize: 500,
					token: dataGrid,
					customUrl: options.customUrl,
					action: {},
					onGetEntityCollection: function(event)
					{

						WAF.utils.debug.console.log("EntityCollection");
						WAF.utils.debug.console.dir(event.result);
						event.token._private.functions.queryEntityCollectionOnGetEntityCollection(event);
					}
				});
			},

			setEntityCollection: function(dataGrid, entityCollection)
			{
				dataGrid._private.globals.entityCollection = entityCollection;
				dataGrid._private.globals.dataStore = entityCollection;
				dataGrid.redraw();
			},

			queryEntityCollectionOnGetEntityCollection: function(event)
			{

				var dataGrid = event.token;

				var itemCount = event.result.count();

				// check if entity count matches row count for the grid
				// if not, update grid row numbers
				if (itemCount != dataGrid.gridController.gridView.getRowCount())
				{
					dataGrid._private.globals.itemCount = itemCount;
					dataGrid.gridController.gridView.setRowCount(itemCount);
				}

				dataGrid._private.globals.dataStore = event;

				// update rows
				// replace with public API
				dataGrid.gridController.gridView._private.functions.updateVisibleRowData({
					gridView: dataGrid.gridController.gridView
				});

			}
			
			*/

		},
		handlers: {}
	};

	/**
	* DataGrid.initWithOptions(options)
	* \~english
	* @brief             Initializes the grid
	* @details           Grid is initialized with options, of which most are optional.
	*
	* @param options : object
	*
	* @return this : DataGrid
	*
	* @code
	*
	* // set options for the grid
	* // create with Contacts datastore class, use default attributes
	*
	* var options = {
	* 	createInNode	: $('#myGrid'),
	* 	dataClass		: 'Contacts'
	* }
	*
	* // create a data grid
	* var myGrid = new WAF.classes.DataGrid().initWithOptions(options);
	*
	* @endcode
	*/
	this.initWithOptions = function(options)
	{

		//WAF.utils.debug.console.log('[DataGrid] WAF.classes.DataGrid._private.functions.initWithOptions called');

		// set reference to the object
		options.dataGrid = this;

		this._private.functions.initWithOptions(options);

		return this;

	}

	this.redraw = function()
	{ 

		if (!this.isInDesign /*&& this._private.globals.dataStore*/)
		{
			var itemCount = this.dataSource.length;

			for (var rowCount = 0; rowCount < this.gridController.gridView._private.globals.rows.length; rowCount++)
			{
				var row = this.gridController.gridView._private.globals.rows[rowCount];
				row.needsDataUpdate = true;
			}

			// check if entity count matches row count for the grid
			// if not, update grid row numbers
			if (itemCount != this.gridController.gridView.getRowCount())
			{
				this._private.globals.itemCount = itemCount;
				this.gridController.gridView.setRowCount(itemCount);
			}

			// this._private.globals.entityCollectionResultEvent = event;

			// update rows
			// replace with public API
			this.gridController.gridView._private.functions.updateVisibleRowData({
				gridView: this.gridController.gridView
			});

			if ($("#containerLoading"))
			{
				$("#containerLoading").fadeOut('fast');
			}

		}
	}


	/*
	// Set grid controller functions
	*/

	this.kill = function()
	{
		this.gridController.gridView.kill();
	}

	this.gridController = new WAF.classes.GridController();
	this.gridController.dataGrid = this;

	this.gridController.getColumnCount = function(grid)
	{

		//WAF.utils.debug.console.log('[DataGrid] WAF.classes.GridController.getColumnCount called');

		return this.dataGrid._private.globals.columnsDefinition.length;
	}

	this.gridController.getRowCount = function(grid)
	{

		//WAF.utils.debug.console.log('[DataGrid] WAF.classes.GridController.getRowCount called');

		return this.dataGrid._private.globals.itemCount;
	}

	this.gridController.setContentForRow = function(rowNumber)
	{

		if (!this.dataGrid.isInDesign)
			//this.dataGrid._private.globals.dataStore.getEntityByPosition(rowNumber, this.parseEntity, this.dataGrid, false);
			this.dataGrid.dataSource.getElement(rowNumber, { onSuccess: this.parseElement, onFailure : this.parseElement}, this.dataGrid)
		// return blank array since we'll call handler that will populate this
		return [];

	}

	this.gridController.setStyleForRow = function(rowNumber)
	{
		/*
		if (rowNumber % 2)
		{
			return {
				rowStyle: 'even'//'rowBG'
			};
		}
		else
		{
			return {
				rowStyle: 'odd'//'alternateRowBG'
			};
		}
		*/
		return {
			rowStyle: ((rowNumber % 2) ? 'waf-widget-odd' : 'waf-widget-even')
		};
	}


	this.gridController.isContentAvailableForRow = function(rowNumber)
	{

		//return this.dataGrid._private.globals.dataStore.isEntityInCache(rowNumber);
		return true;
	}

	this.gridController.onHeaderClick = function(cell, columnNumber)
	{
		if (!this.dataGrid.isInDesign)
		{
            //console.log(this.dataGrid._private.globals.columnsDefinition[columnNumber])
			if (!this.dataGrid._private.globals.columnsDefinition[columnNumber].sortable)
			{
				return;
			}

			if ($("#containerLoading"))
			{
				$("#containerLoading").show();
			}

			// Set the sortOrder
			if (this.dataGrid.sortColumn != null)
			{
				// Clear sortIndicator
				this.dataGrid.gridController.gridView.resetSortIndicator(this.dataGrid.sortColumn);

				if (columnNumber === this.dataGrid.sortColumn)
				{
					if ((!this.dataGrid.sortOrder) | (this.dataGrid.sortOrder === 'desc'))
					{
						this.dataGrid.sortOrder = 'asc';
					}
					else
					{
						this.dataGrid.sortOrder = 'desc';
					}
				}
				else
				{
					this.dataGrid.sortOrder = 'asc';
				}
			}
			else
			{
				this.dataGrid.sortOrder = 'asc';
			}

			this.dataGrid.sortColumn = columnNumber;
			this.dataGrid.gridController.gridView.setSortIndicator(this.dataGrid.sortColumn, this.dataGrid.sortOrder);
			this.dataGrid.dataSource.orderBy(this.dataGrid._private.globals.columnsDefinition[columnNumber].sourceAttID + " " + this.dataGrid.sortOrder);
		}
	}

	/*
	// Custom grid controller functions
	*/
	
	this.gridController.parseElement = function(event)
	{
		var dataGrid = event.data;
		var rowNumber = event.position;
		var elem = event.element;
		var rowContents = [];
		var row = null;
		
		if (event.error != null && event.error.length > 0)
		{
			var attributeList = dataGrid._private.globals.columnsDefinition;

			for (var attributeCount = 0; attributeCount < attributeList.length; attributeCount++)
			{
				//rowContents.push("##error##");
				rowContents.push("");
			}
		}
		else
		{
			var attributeList = dataGrid._private.globals.columnsDefinition;

			for (var attributeCount = 0; attributeCount < attributeList.length; attributeCount++)
			{
				var renderedContent = null;
				var attgrid = attributeList[attributeCount];
				var attName = attgrid.sourceAttID;
				var entAtt = elem == null ? null : /*elem[attName]*/elem.getAttributeValue(attName);
				var col = dataGrid.gridController.gridView.column(attributeCount+1);


				if (col.renderer != null)
				{
					var gridView = dataGrid.gridController.gridView;
					if (row == null)
						row = gridView._private.functions.getRowByRowNumber({gridView: gridView, rowNumber: rowNumber});
					if (row == null)
						renderedContent = "";
					else
					{
						var cell = row.cells[attributeCount];
						if (cell != null)
							renderedContent = col.renderer({ value: entAtt, rowNumber:event.position, dataSource:event.dataSource, cellDiv: cell.insideCell});
					}
				}

				if (!renderedContent)
				{
					var dataClassAtt = col.att;
					if (dataClassAtt != null) 
					{
						if (dataClassAtt.type !== 'image') 
						{
							var xcontent = entAtt;
							if (xcontent == null) 
							{
								xcontent = "";
							}
							else 
							{
								xcontent = col.getFormattedValue(xcontent);
							}
							rowContents.push(xcontent);
						}
						else 
						{
							if (entAtt && !!entAtt.uri)
							{
								rowContents.push("<img alt='' src='" + entAtt.uri + "'/>");
							}
							else 
							{
								rowContents.push("");
							}
						}
					}
				}
				else
				{
					rowContents.push(renderedContent);
				}
			}			
		}
		dataGrid.gridController.gridView.setRowContents(rowNumber, rowContents);
	}
	
	
	this.column = function(colRef, colSettings)
	{
		return this.gridController.gridView.column(colRef, colSettings);
	}

	this.columns = function(colSettings)
	{
		return this.gridController.gridView.columns(colSettings);
	}
	
	this.centerRow = function(rowNumber, options)
	{
		options = options;
		var gridView = this.gridController.gridView;
		gridView.centerRow(rowNumber, options);
	}
	
	this.setOptions = function(options)
	{
		var gridView = this.gridController.gridView;
		gridView.setOptions(options);
	}
	
	this.setReadOnly = function(inReadOnly)
	{
		var doLock = true;
		if(arguments.length > 0 && typeof inReadOnly === 'boolean') {
			doLock = inReadOnly;
		}
		
		// Toolbar
		if(doLock) {
			$("#" + this.subscriberID + " .waf-dataGrid-footer .waf-toolbar").hide();
		} else {
			$("#" + this.subscriberID + " .waf-dataGrid-footer .waf-toolbar").show();
		}
	
		// Columns
		var cols = this.columns();
		if(cols != null) {
			cols.forEach( function(theCol, idx, arr) {
				theCol.readOnly = doLock;
			});
		}
	}
	
	this.getSortIndicator = function()
	{
	// One or all elements may be null. order is a string, 'asc', 'desc'
		return { colNb: this.sortColumn, order: this.sortOrder };
	}
	
	this.setSortIndicator = function(colNum, order)
	{
		this.sortColumn = colNum;
		this.sortOrder = order;
		this.gridController.gridView.setSortIndicator(colNum, order);
	}
	
	this.resetSortIndicator = function()
	{
		this.sortColumn = null;
		this.sortOrder = null;
		this.gridController.gridView.resetSortIndicator(columnNb);
	}
	
	// Sort only the first columns found with a sort indicator
	this.sortAgain = function(options, userData) // options is optionnal. Contains the usual onSuccess/onError callbacks
	{
		var		col = this.sortColumn !== null ? this.sortColumn : -1,
				order = this.sortOrder ? this.sortOrder : '';
		options = options || {};
		userData = userData || null;
		
		if(col >= 0 && (order === 'asc' || order === 'desc')) {
			this.dataSource.orderBy(this._private.globals.columnsDefinition[col].sourceAttID + " " + order, options, userData);
		}
	}

	/*
	// Constructor
	*/
	if (!!options)
	{
		this.initWithOptions(options);
	}
	
	
	        // subscribe to the dataSource if any
	        
	var gridThis = this;
	
    if (!this.isInDesign && this.dataSource != null)
    {
		this.dataSource.addListener("all", WAF.classes.DataGrid.gridSourceEventHandler, {listenerID:options.subscriberID, listenerType:'grid'}, {dataGrid:this});
    }

    // default behaviour
    if (!this.isInDesign && this.dataSource != null)
    {
        this.gridController.onRowClick = function(position)
        {
            //if (this.dataSource._private.subscribers.length > 0)
            
                //gridThis.dataSource.select(position);
            
        };
    }


	return this;

}


WAF.classes.DataGrid.gridSourceEventHandler = function(event)
{
	var grid = event.data.dataGrid;
	if (event.eventKind == 'onCollectionChange') 
	{
		grid.redraw(); 
	}
	else if (event.eventKind == "attributeChange") 
	{
		var posInSource = event.dataSource.getPosition();
		var col = grid.column(event.attributeName);
		var updateval = event.dataSource[event.attributeName];
		/*
		if (col != null) 
			updateval = col.getFormattedValue(updateval);
			*/
		grid.gridController.gridView.updateCell(posInSource, event.attributeName /* faire une indirection ici pour retrouver le colID a a partir de l'attribute name*/, updateval);
	}
	else if (event.eventKind == 'onBeforeCurrentElementChange') 
	{
		var posInSource = event.dataSource.getPosition();
		var cols = grid.columns();
		for (var i = 0; i < cols.length; i++) 
		{
			var col = cols[i];
			var sourceAtt = event.dataSource.getAttribute(col.sourceAttID);
			if (sourceAtt != null) 
			{
				grid.gridController.gridView.updateCell(posInSource, col.sourceAttID, sourceAtt.getOldValue());
			}
		}
	}
	else if (event.eventKind == 'onCurrentElementChange') 
	{
		var posInSource = event.dataSource.getPosition();
		grid.gridController.gridView.setCurrentRow(posInSource);
		
		var cols = grid.columns();
		for (var i = 0; i < cols.length; i++) 
		{
			var col = cols[i];
			//var sourceAtt = event.dataSource.getAttribute(col.sourceAttID);
			grid.gridController.gridView.updateCell(posInSource, col.colID, event.dataSource.getAttributeValue(col.sourceAttID));
		
			$("#"+grid.subscriberID+ "-viewportNode").trigger('touchend');
						
			/*
			if (sourceAtt != null) 
			{
				grid.gridController.gridView.updateCell(posInSource, col.sourceAttID, sourceAtt.getValue());
			}
			*/
		}
	}
}





/**
 * ----------------------------------------------------------------------------
 * content of widget-dataGrid-view.js
 * ----------------------------------------------------------------------------
 */


/**
 * @brief			GridView, part of WAF/UI/Grid
 * @details			Infinite scrolling grid object
 * 
 * 
 *  
 * @author			rudolfpsenicnik
 * @date			February 2009 
 * @version			1.0
 * 
 * @include			copyright.txt
 */

if (WAF.gridUtil == null)
{
	WAF.gridUtil = {};
}

WAF.classes.GridView = function()
{

	var theGridView = this;
	// Private
	this._private = {
		globals: {

			options: {
				autoScrollOnSelected: true
			},
			
			// DOM nodes
			headerNode: null, 	// headerNode - viewport for the column titles
			headerContainerNode: null, 	// headerContainerNode - container for header row bound horizontally to viewportContainerNode
			targetNode: null, 	// DOM node where grid is inserted
			viewportNode: null, 	// viewport node that holds scrollable content (rows)
			viewportContainerNode: null, 	// container for viewports, provides system scrollbars
			statusNode: null, 	// statusNode - viewport for status bar

			// rows	
			rows: [], 	// array of row objects
			pageSize: 0, 	// how many rows per page.
			visibleRowCount: 0, 	// how many rows are visible on screen at one time?
			visibleAndCacheRowCount: 0, 	// visible and cached row count
			totalRowCount: 0, 	// how many rows should there be in total?
			rowHeight: 50, 	// used to calculate viewport height
			enableAlternateRowStyling: true, 	// 

			rowContentUpdateDelayInMs: 0, 	/*	miliseconds that need to pass before requesting data for row
															set to 0 to disable
															this is to prevent too many row content update requests
															while rapidly scrolling
														*/
			rowContentUpdateDelayEvent: null, 	// row content update delay window.setTimeout event
			useHoverEffectForRows: false, 	// applies .hover class name to row when hovered over

			// columns
			columns: [], 	// array of column objects

			// cells
			cellNeedsUpdateHTMLContent: '', 	// displayed in cell that is still waiting for data

			// cache
			cacheSizeInPages: 0, 	// how many pages of rows will be rendered off-screen
			cacheSizeInRows: 0, 	// calculated based on number of cache pages

			// flags
			currentlyUpdatingRowPositions: false, // rows are being repositioned

			vScrollBarWidth: 15,
			
			resizeHasBeenStarted: false,
			editHasBeenStarted: false,
			currentRow: -1

		},
		functions: {

			// initializes the grid with passed options
			initWithOptions: function(options)
			{

				//WAF.utils.debug.console.log('[GridView] WAF.classes.GridView._private.functions.initWithOptions called');

				var gridView = options.gridView;

				if ((options.cacheSize != undefined) && (options.cacheSize != null))
				{
					gridView._private.globals.cacheSizeInPages = options.cacheSize;
				}

				if (!!options.rowHeight)
				{
					gridView._private.globals.rowHeight = options.rowHeight;
				}

				// create DOM node and insert basic DOM elements
				gridView._private.functions.initGridDOMatNode({node: options.createInNode, gridView: gridView, columns: options.columns, cls: options.cls});

			},

			// sets up grid at specified node, creates basic DOM elements
			initGridDOMatNode: function(options)
			{

				//WAF.utils.debug.console.log('[GridView] WAF.classes.GridView._private.functions.initGridDOMatNode called');

				var gridView = options.gridView;

				// set grid node as private variable
				var targetNode = options.node;
				gridView._private.globals.targetNode = options.node;
				
				targetNode
                    .attr('data-type', 'dataGrid')
                    .addClass('waf-widget waf-dataGrid ' + options.cls || '')
                    .empty();


				// create header node
				var headerNode = $('<div></div>').addClass('waf-widget-header waf-dataGrid-header waf-user-select-none');
				gridView._private.globals.headerNode = headerNode;

				// add header node to DOM
				headerNode.appendTo(targetNode);

				// add header container to DOM
				var headerContainerNode = $('<div></div>').addClass('container');
				gridView._private.globals.headerContainerNode = headerContainerNode;
				headerContainerNode.appendTo(headerNode);

				// create viewport node
				var viewportNode = $('<div></div>').addClass('waf-widget-body waf-dataGrid-body');
				viewportNode.attr('id', options.node[0].id + "-viewportNode"); /* for mobile add id */
				gridView._private.globals.viewportNode = viewportNode;

				// add viewport node to DOM
				viewportNode.appendTo(targetNode);
                
				// add viewport container to DOM
				var viewportContainerNode = $('<div></div>').addClass('container');
				viewportContainerNode[0].id = options.node[0].id + "-viewportContainerNode"; /* for mobile add id */
				gridView._private.globals.viewportContainerNode = viewportContainerNode;
				viewportContainerNode.appendTo(viewportNode);

                // bind events ; for mobile add bind touchend rather than scroll 
				viewportContainerNode.bind('touchmove', {gridView: gridView}, function() {
				     //gridView._private.globals.rowTouchStart = new Date().getTime();
				     gridView._private.globals.headerContainerNode.css("margin-left", gridView._private.globals.viewportContainerNode.position().left+"px")
				     gridView._private.globals.containerMoved = true; 
				     gridView._private.globals.istouch = false;
				});
				viewportNode.bind('touchend', {gridView: gridView}, gridView._private.functions.onViewportScroll);
				//viewportNode.bind('touchmove', {gridView: gridView}, gridView._private.functions.onViewportScroll);

   

				// create status node
				var statusNode = $('<div></div>').addClass('waf-widget-footer waf-dataGrid-footer waf-status waf-user-select-none');
				gridView._private.globals.statusNode = statusNode;

				// add status node to DOM
				statusNode.appendTo(targetNode);

				// create statusLeftContainer node
				var statusLeftContainer = $('<div></div>').addClass('waf-status-element waf-status-left');
				gridView._private.globals.statusLeftContainer = statusLeftContainer;
				
				statusLeftContainer.appendTo(statusNode);
                
				if (gridView.gridController.dataGrid.isIncluded)
				{
					// in the futur we may generate a special toolbar
				}
				else
				{
					var toolbar = new WAF.widget.Toolbar([    /* for mobile change the scale of the button */
	                    {icon: {
	                        size: 24, 
	                        type: 'plus', 
	                        state: {
                                normal: {
                                    scale: 1.3,
                                }
                            },
	                        }, text: '', title: 'Add', click: !gridView.gridController.dataGrid.isInDesign && function() {WAF.gridUtil.addRow(gridView);}},
	                    {icon: {
	                        size: 24, 
	                        type: 'minus', 
	                        state: {
                                normal: {
                                    scale: 1.3,
                                }
                            },
	                    }, text: '', title: 'Delete', click: !gridView.gridController.dataGrid.isInDesign && function() {WAF.gridUtil.delRow(gridView);}}
	                ]);
	                
	                toolbar.appendTo(statusLeftContainer);
				}
                
				/* if (!gridView.gridController.dataGrid.isInDesign)
				{
					toolbar.find('.waf-button').bind('click', {gridView: gridView}, function(event)
					{
						var gridView = event.data.gridView;
						WAF.gridUtil[$(this).attr('data-action')](gridView);
					});
				} */
                
				// create statusCenterContainer node
				var statusCenterContainer = $('<div></div>').addClass('waf-status-element waf-status-center');
				gridView._private.globals.statusCenterContainer = statusCenterContainer;

				// add statusCenterContainer node to DOM
				statusCenterContainer.appendTo(statusNode);

				// create statusRightContainer node
				var statusRightContainer = $('<div></div>').addClass('waf-status-element waf-status-right');
				gridView._private.globals.statusRightContainer = statusRightContainer;

				// add statusRightContainer node to DOM
				statusRightContainer.appendTo(statusNode);

				// need to know column count at this point
				// check with controller for column number
				if (!!gridView.gridController)
				{
					if (!!gridView.gridController.getColumnCount)
					{
						var columnCount = gridView.gridController.getColumnCount(gridView);
						if (!!columnCount)
						{
							gridView._private.functions.setColumnCount({gridView: gridView, columnCount: columnCount, columns: options.columns});
						}
					}
				}

				// resize viewport and container
				gridView._private.functions.updateHeaderSize({gridView: gridView});
				gridView._private.functions.updateViewportSize({gridView: gridView});
				gridView._private.functions.updateStatusSize({gridView: gridView});
				gridView._private.functions.updateViewportContainerSize({gridView: gridView});


				// add rows and cells
				gridView._private.functions.updateDOMToMatchRowAndColumnCounts({gridView: gridView, columns: options.columns});

			},

			refresh: function(options)
			{ 

				var gridView = options.gridView;

				// resize viewport and container
				gridView._private.functions.updateViewportContainerSize({gridView: gridView});

				// add rows and cells
				gridView._private.functions.updateDOMToMatchRowAndColumnCounts({gridView: gridView});

				// mark all rows as needing data
				for (var rowCount = 0; rowCount < gridView._private.globals.rows.length; rowCount++)
				{
					gridView._private.globals.rows[rowCount].needsDataUpdate = true;
				}

				// repopulate with data
				gridView._private.functions.updateVisibleRowData({gridView: gridView});

			},

			setTotalRowCount: function(options)
			{

				var gridView = options.gridView;
				var rowCount = options.rowCount;

				gridView._private.globals.totalRowCount = rowCount;

				// resize viewport and container
				gridView._private.functions.updateViewportSize({gridView: gridView});
				gridView._private.functions.updateViewportContainerSize({gridView: gridView});

				// update status bar
				gridView._private.globals.statusCenterContainer.html(rowCount + " items")

				// add rows and cells
				gridView._private.functions.updateDOMToMatchRowAndColumnCounts({gridView: gridView});
				
				
			    //add specific scroll behavior for mobile to the viewport container
                setTimeout(function () {
                   if( !gridView._private.scrollObject && rowCount != 1 ){

                      gridView._private.scrollObject = new iScroll(gridView._private.globals.targetNode[0].id + "-viewportNode", {"desktopCompatibility":false});
                        
                   }
                }, 200);


			},

			// sets number of columns and creates column objects
			setColumnCount: function(options)
			{

				var gridView = options.gridView;
				var setColumnCount = options.columnCount;
				gridView._private.globals.colsByID={};

				// loop with column count and create column objects
				for (var columnCount = 0; columnCount < setColumnCount; columnCount++)
				{

					// create column object
					var optcol = options.columns[columnCount];
					var xatt = null;
					var sourceAtt = null;
					var xsource = gridView.gridController.dataGrid.dataSource;
					if (xsource != null)
					{
						if (xsource.getClassAttributeByName != null)
						{
							xatt = xsource.getClassAttributeByName(optcol.sourceAttID);
							if (xatt != null)
								xsource.declareDependencies(optcol.sourceAttID);
						}
						if (xsource.getAttribute != null)
						{
							sourceAtt = xsource.getAttribute(optcol.sourceAttID);
						}		
					} 
					var format = {};
					if (xatt != null && xatt.defaultFormat != null)
						format = xatt.defaultFormat;
					if (optcol.format != null)
						format = optcol.format;
					var readOnly = false;
					if (optcol.readOnly || xatt == null || xatt.readOnly)
						readOnly = true;
					if (sourceAtt == null || !sourceAtt.isFirstLevel || !sourceAtt.simple)
						readOnly = true;

					var column = {
						columnNumber: columnCount,
						title: optcol.title,
						style: optcol.style,
						width: optcol.width,
						format: format,
						readOnly: readOnly,
						originalWidth: optcol.width,
						sourceAttID: optcol.sourceAttID,
						colID: optcol.colID,
						gridview: gridView,
						setTextSize:WAF.classes.GridColumn.setTextSize,
						setFontSize:WAF.classes.GridColumn.setTextSize,
						setWidth:WAF.classes.GridColumn.setWidth,
						setColor:WAF.classes.GridColumn.setColor,
						setBackgroundColor:WAF.classes.GridColumn.setBackgroundColor,
						setRenderer:WAF.classes.GridColumn.setRenderer,
						setFormat:WAF.classes.GridColumn.setFormat,
						source: xsource,
						att: xatt,
						getFormattedValue: WAF.AF.getFormattedValue,
						getValueForInput: WAF.AF.getValueForInput
					};

					// check for column properties
					if (!!gridView.gridController.setPropertiesForColumn)
					{
						var columnPropertiesFromController = gridView.gridController.setPropertiesForColumn(column);

						if (!!columnPropertiesFromController.width)
						{
							column.width = columnPropertiesFromController.width;
						}
					}

					// add column object to array
					gridView._private.globals.columns.push(column);
					gridView._private.globals.colsByID[optcol.colID] = column;
				}
			},

			// updates width and height for viewport container based targetNode size
			updateViewportSize: function(options)
			{ 
				var gridView = options.gridView;

				// set position of targetNode, which is DOM element where grid was created in
				gridView._private.globals.viewportNode.css({
					left: 0,
					right: 0,
					top: '35px',
					bottom: '40px'
				});
				// gridView._private.globals.viewportNode.height(gridView._private.globals.targetNode.height() - 25 - 20); // J.F. header code
			},

			// updates width and height for header container based targetNode size
			updateHeaderSize: function(options)
			{

				var gridView = options.gridView;

				// set position of headerNode and height to 25, which is DOM element where grid was created in
				gridView._private.globals.headerNode.css({
					left: 0,
					right: 0
				});
				gridView._private.globals.headerNode.height(35); // J.F. If customize modify updateViewportSize too "- 25"
			},

			// updates width and height for status container based targetNode size
			updateStatusSize: function(options)
			{

				var gridView = options.gridView;

				// set position ofstatusNode and height to 15, which is DOM element where grid was created in
				gridView._private.globals.statusNode.css({
					left: 0,
					right: 0,
					bottom: 0
				});
				gridView._private.globals.statusNode.height(40); // J.F. If customize modify updateViewportSize too "- 20"
			},

			// updates width and height for viewport container based on row & column properties
			updateViewportContainerSize: function(options)
			{

				var gridView = options.gridView;

				// width of container is width of all columns combined, calculate it
				var width = 0;
				for (var columnCount = 0; columnCount < gridView._private.globals.columns.length; columnCount++)
				{
					width += parseInt(gridView._private.globals.columns[columnCount].originalWidth);
				}

				if (width < gridView._private.globals.viewportNode.width())
				{
					width = parseInt(gridView._private.globals.viewportNode.width());
				}

				// set container width
				gridView._private.globals.viewportContainerNode.width(width);

				// set header width
				gridView._private.globals.headerContainerNode.width(width + gridView._private.globals.vScrollBarWidth); // Add 50 in case vertical scrolbar is displayed

				// container height is (number of rows * row height);
				var numberOfRows = 0;
				if (!!gridView.gridController)
				{
					if (gridView.gridController.dataGrid.isInDesign)
					{
						numberOfRows = 200;
						gridView._private.globals.totalRowCount = numberOfRows;
					}
					else if (!!gridView.gridController.getRowCount)
					{
						var numberOfRows = gridView.gridController.getRowCount(gridView);
						gridView._private.globals.totalRowCount = numberOfRows;
					}
				}

				var height = gridView._private.globals.rowHeight * numberOfRows;
				if ((height > 17895697) & (WAF.utils.environment.browser.firefox3))
				{
					gridView._private.globals.viewportContainerNode.height(17895697);
				}
				else
				{
					gridView._private.globals.viewportContainerNode.height(height);
				}
			},

			// updates number of row and cell DOM objects based on internal counts
			updateDOMToMatchRowAndColumnCounts: function(options)
			{  
				var gridView = options.gridView;

				// calculate number of visible rows
				var visibleRowCount = Math.ceil(gridView._private.globals.targetNode.height() / gridView._private.globals.rowHeight) + 1;

				gridView._private.globals.pageSize = visibleRowCount;

				// increase number of rows by cache page size
				var rowCacheCount = Math.ceil(visibleRowCount * gridView._private.globals.cacheSizeInPages);
				var visibleAndCacheRowCount = visibleRowCount + (rowCacheCount * 2);

				// in case visible rows + cache page rows > total Row count
				if (visibleAndCacheRowCount > gridView._private.globals.totalRowCount)
				{
					visibleAndCacheRowCount = gridView._private.globals.totalRowCount;
				}

				// set global variables
				gridView._private.globals.visibleRowCount = visibleRowCount;
				gridView._private.globals.visibleAndCacheRowCount = visibleAndCacheRowCount;
				gridView._private.globals.cacheSizeInRows = rowCacheCount;

				// column count for later
				var numberOfColumns = gridView.gridController.getColumnCount();

				// Update Header
				// Check Headers
				if (gridView._private.globals.headerContainerNode.cells == undefined)
				{
					gridView._private.globals.headerContainerNode.cells = [];
				}

				// do we need to remove header cells?
				while (gridView._private.globals.headerContainerNode.cells.length > numberOfColumns)
				{
					var cell = gridView._private.globals.headerContainerNode.cells.pop();
					cell.dom.remove();
					//WAF.utils.debug.console.log('removing header cell');
				}

                                var totalWidth = 0;
				// add Header Cells
				while (gridView._private.globals.headerContainerNode.cells.length < numberOfColumns)
				{

                    // Setting cell dom
					var attributeCount = gridView._private.globals.headerContainerNode.cells.length;

					var col = gridView._private.globals.columns[attributeCount];
					var id = col.colID;
					var cellWidth = col.width;                                        
                                        
                                        // Set last column width
                                        if (attributeCount === numberOfColumns - 1) {
                                           cellWidth = gridView._private.globals.viewportContainerNode.width() - totalWidth;
                                        }

                                        totalWidth += cellWidth;

					var cell = {
						dom: $('<div class="waf-dataGrid-cell waf-dataGrid-col-'+ id + ' waf-dataGrid-col-' + attributeCount + '"></div>').appendTo(gridView._private.globals.headerContainerNode)
					}

					if (options.columns[attributeCount].sortable)
					{
						cell.dom.addClass('clickable');
					}

                    try {
                        cell.dom.width(cellWidth - parseInt(cell.dom.css('border-left-width')) - parseInt(cell.dom.css('border-right-width')) - parseInt(cell.dom.css('padding-left')) - parseInt(cell.dom.css('padding-right')) - parseInt(cell.dom.css('margin-left')) - parseInt(cell.dom.css('margin-right')));
                    } catch (e) {
                        cell.dom.width(cellWidth);
                    }
                    
                    
                    // Setting sortIndicator
                    var sortUpIcon = new WAF.widget.Icon(
                        {
                            size: 16,
                            type: 'arrowUp',
                            className: 'waf-icon-sortAsc'/*,
                            state: {
                                normal: {
                                    fill: '#fff'
                                },
                                hover: {
                                    fill: '#d00'
                                },
                                active: {
                                    fill: '#0f0'
                                }
                            }*/
                        }
                    );
					
                    var sortDescIcon = new WAF.widget.Icon(
                        {
                            size: 16,
                            type: 'arrowDown',
                            className: 'waf-icon-sortDesc'/*,
                            state: {
                                normal: {
                                    fill: '#fff'
                                },
                                hover: {
                                    fill: '#d00'
                                },
                                active: {
                                    fill: '#0f0'
                                }
                            }*/
                        }
                    );
                    
                    cell.sortIndicator = $('<div class="waf-sort"></div>')
                        .append(sortUpIcon.containerNode)
                        .append(sortDescIcon.containerNode);
                    
                    // Setting cell title
					cell.title = $('<div class="content"></div>');
                    
                    // Setting cell resizeIndicator
					cell.resizeIndicator = $('<div class="resize"></div>');
                    
                    // Appending cell content
                    cell.dom.append(
                        cell.title,
                        cell.sortIndicator,
                        cell.resizeIndicator
                    );

					cell.dom.bind('click', {gridView: gridView, cell: cell, columnNumber: attributeCount}, gridView._private.functions.onHeaderClick);
					gridView._private.globals.headerContainerNode.cells.push(cell);
					cell.resizeIndicator.gridView = gridView;
					//cell.resizeIndicator.bind('mousedown', {gridView: gridView, columnNumber: attributeCount}, gridView._private.functions.startColResize);
					cell.resizeIndicator.bind('click',{gridView: gridView,columnNumber: attributeCount},gridView._private.functions.onResizeClick);
				}


				// set Header titles
				for (var columnCount = 0; columnCount < numberOfColumns; columnCount++)
				{
					if (options.columns)
					{
						gridView._private.globals.headerContainerNode.cells[columnCount].title.html(options.columns[columnCount].title);
					}
				}

				// calculate width				
				var width = 0;
				for (var columnCount = 0; columnCount < gridView._private.globals.columns.length; columnCount++)
				{
                                        // Set last column width
                                        if (columnCount === gridView._private.globals.columns.length - 1) {
                                           var lastWidth = gridView._private.globals.viewportContainerNode.width() - width;
                                           width += lastWidth - 1;
                                        } else {
                                            width += gridView._private.globals.columns[columnCount].originalWidth;
                                        }

				}
				// taking borders' width into account
				width += gridView._private.globals.columns.length - 1;
				if (gridView._private.globals.totalRowCount < visibleRowCount)
				{
					// do we need to remove rows?
					while (gridView._private.globals.rows.length > visibleRowCount)
					{
						var row = gridView._private.globals.rows.pop();
						row.dom.remove();
						//WAF.utils.debug.console.log('removing row');
					}

					//if (width < gridView._private.globals.viewportNode.width()) {
					//	width = gridView._private.globals.viewportNode.width();
					//}

				}
				else
				{
					//if (width < gridView._private.globals.viewportNode.width() - gridView._private.globals.vScrollBarWidth) {
					//	width = gridView._private.globals.viewportNode.width() - gridView._private.globals.vScrollBarWidth;
					//}

					gridView._private.globals.viewportContainerNode.width(width)
				}

				if (gridView.gridController.dataGrid.isInDesign)
				{
					var row = {
							dom: $('<div></div>').addClass('waf-widget-content waf-dataGrid-row').appendTo(gridView._private.globals.viewportContainerNode),
							offsetTop: rowNumber * gridView._private.globals.rowHeight, // viewport offset used to position row
							rowNumber: 0,
							needsDataUpdate: false,
							cells: [],
							style: '',
							oldStyle: ''
					}
					row.dom.width(width);
					try {
                        row.dom.height(gridView._private.globals.rowHeight - parseInt(row.dom.css('border-bottom-width')) - parseInt(row.dom.css('border-top-width')) - parseInt(row.dom.css('padding-bottom')) - parseInt(row.dom.css('padding-top')) - parseInt(row.dom.css('margin-bottom')) - parseInt(row.dom.css('margin-top')));
                    } catch (e) {
                        row.dom.height(gridView._private.globals.rowHeight);
                    }
                    for (var attributeCount = 0; attributeCount < numberOfColumns; attributeCount++)
                    {
						var col = gridView._private.globals.columns[attributeCount];
                        var cellWidth = col.width;
                        var cellStyle = col.style;
						var id = col.colID;

                        var cell = {
                                dom: $('<div class="waf-dataGrid-cell waf-dataGrid-col-' + id + ' waf-dataGrid-col-' + attributeCount +'"></div>').addClass(cellStyle).appendTo(row.dom)
                        }
                        cell.insideCell = $('<div class="content">Text</div>').appendTo(cell.dom);

                        try {
                            cell.dom.width(cellWidth - parseInt(cell.dom.css('border-left-width')) - parseInt(cell.dom.css('border-right-width')) - parseInt(cell.dom.css('padding-left')) - parseInt(cell.dom.css('padding-right')) - parseInt(cell.dom.css('margin-left')) - parseInt(cell.dom.css('margin-right')))
                        } catch(e) {
                            cell.dom.width(cellWidth);
                        }

                        try {
                            cell.dom.height(gridView._private.globals.rowHeight - parseInt(row.dom.css('border-bottom-width')) - parseInt(row.dom.css('border-top-width')) - parseInt(row.dom.css('padding-bottom')) - parseInt(row.dom.css('padding-top')) - parseInt(row.dom.css('margin-bottom')) - parseInt(row.dom.css('margin-top')) - parseInt(cell.dom.css('border-bottom-width')) - parseInt(cell.dom.css('border-top-width')) - parseInt(cell.dom.css('padding-bottom')) - parseInt(cell.dom.css('padding-top')) - parseInt(cell.dom.css('margin-bottom')) - parseInt(cell.dom.css('margin-top')));
                        } catch(e) {
                            cell.dom.height(gridView._private.globals.rowHeight);
                        }

                        row.cells.push(cell);
                    }
				}
				else
				{
					// do we need to add rows?
					var rowNumber = gridView._private.globals.rows.length;
					while (gridView._private.globals.rows.length < visibleAndCacheRowCount)
					{
	
						var row = {
							dom: $('<div></div>').addClass('waf-widget-content waf-dataGrid-row').appendTo(gridView._private.globals.viewportContainerNode),
							offsetTop: rowNumber * gridView._private.globals.rowHeight, // viewport offset used to position row
							rowNumber: rowNumber,
							needsDataUpdate: true,
							cells: [],
							style: '',
							oldStyle: ''
						}
	
						//WAF.utils.debug.console.log('adding row ' + rowNumber);
	
						// update row width
						row.dom.width(width);
	
						// update row height
                        try {
                            row.dom.height(gridView._private.globals.rowHeight - parseInt(row.dom.css('border-bottom-width')) - parseInt(row.dom.css('border-top-width')) - parseInt(row.dom.css('padding-bottom')) - parseInt(row.dom.css('padding-top')) - parseInt(row.dom.css('margin-bottom')) - parseInt(row.dom.css('margin-top')));
                        } catch (e) {
                            row.dom.height(gridView._private.globals.rowHeight);
                        }
	
	
						// apply events
                        if (!gridView.gridController.dataGrid.isInDesign) {
                            // apply hover styles to rows if turned on 
                            row.dom.bind('click', {gridView: gridView, row: row}, gridView._private.functions.onRowClick);
                            

                            // increment row number
                            rowNumber++;

                            // add cells
                            for (var attributeCount = 0; attributeCount < numberOfColumns; attributeCount++)
                            {
								var col = gridView._private.globals.columns[attributeCount];
                                var cellWidth = col.width;
                                var cellStyle = col.style;
								var id = col.colID;

                                var cell = {
                                        //dom: $('<div></div>').addClass('cellCol' + attributeCount).addClass('cell').addClass('noUserSelect').addClass(cellStyle).appendTo(row.dom)
                                        dom: $('<div class="waf-dataGrid-cell waf-dataGrid-col-' + id + ' waf-dataGrid-col-' + attributeCount +'"></div>').addClass(cellStyle).appendTo(row.dom)
                                }
                                //cell.insideCell = $('<div></div>').addClass('insideCell').appendTo(cell.dom);
                                cell.insideCell = $('<div class="content"></div>').appendTo(cell.dom);

                                try {
                                    cell.dom.width(cellWidth - parseInt(cell.dom.css('border-left-width')) - parseInt(cell.dom.css('border-right-width')) - parseInt(cell.dom.css('padding-left')) - parseInt(cell.dom.css('padding-right')) - parseInt(cell.dom.css('margin-left')) - parseInt(cell.dom.css('margin-right')))
                                } catch(e) {
                                    cell.dom.width(cellWidth);
                                }

                                try {
                                    cell.dom.height(gridView._private.globals.rowHeight - parseInt(row.dom.css('border-bottom-width')) - parseInt(row.dom.css('border-top-width')) - parseInt(row.dom.css('padding-bottom')) - parseInt(row.dom.css('padding-top')) - parseInt(row.dom.css('margin-bottom')) - parseInt(row.dom.css('margin-top')) - parseInt(cell.dom.css('border-bottom-width')) - parseInt(cell.dom.css('border-top-width')) - parseInt(cell.dom.css('padding-bottom')) - parseInt(cell.dom.css('padding-top')) - parseInt(cell.dom.css('margin-bottom')) - parseInt(cell.dom.css('margin-top')));
                                } catch(e) {
                                    cell.dom.height(gridView._private.globals.rowHeight);
                                }

                                row.cells.push(cell);
                                
                                
                                //for mobile add touchstart & touchend rather than dblClick
                                cell.dom.bind('touchstart', {gridView: gridView, columnNumber: attributeCount, row: row, cell: cell}, function(event){ 
                                    //gridView._private.globals.rowTouchStart = new Date().getTime(); 
                                    gridView._private.globals.istouch = true;
                                    window.setTimeout(function() {
                                        if(gridView._private.globals.istouch) { 
                                            gridView._private.globals.istouch = false;
                                            gridView._private.functions.onCellDblClick(event)
                                        }
                                    }, 200);
                                });
                                
                                //cell.dom.bind('touchend', {gridView: gridView, columnNumber: attributeCount, row: row, cell: cell}, gridView._private.functions.onCellDblClick);
                                cell.dom.bind('touchend', {gridView: gridView, columnNumber: attributeCount, row: row, cell: cell}, function(event){  
                                    
                                    var gridView = event.data.gridView;
                                    gridView._private.globals.istouch = false; 
                                    
                                });
                            }
                        }

						gridView._private.globals.rows.push(row);
					}
				}
			},

			// fires when viewport scrollbar sends onscroll event
			onViewportScroll: function(event)
			{   
			    var gridView = event.data.gridView;

			    if( !gridView._private.globals.rowClicked ) {

                    var topStart = gridView._private.globals.viewportContainerNode.position().top,
                        leftStart = gridView._private.globals.viewportContainerNode.position().left,
                        topVal,
                        leftVal, 
                        count = 0;

                    var timer = setInterval( function() {

                        topVal = gridView._private.globals.viewportContainerNode.position().top;
                        leftVal = gridView._private.globals.viewportContainerNode.position().left;    

                        if( topVal != topStart || leftVal != leftStart || count == 0) {
                            count++;
                            //clearInterval(timer);
                            if ( leftVal != leftStart ) {
                                gridView._private.globals.headerContainerNode.css("margin-left", leftVal+"px");
                            }
                            
                    		gridView._private.functions.hideCurrentRow({gridView: gridView});
                    		gridView._private.functions.updateRowPositions({gridView: gridView});
                    		gridView._private.functions.updateVisibleRowData({gridView: gridView});
                    		gridView._private.functions.showCurrentRow({gridView: gridView});
                            topStart = topVal;
                        } else {
                            clearInterval(timer);
                            gridView._private.globals.containerMoved = false;
                            //topStart = topVal;
                        }

                    }, 40);
			    } else { 
			        gridView._private.globals.rowClicked = false;
			    }
                
			},
			
			showCurrentRow: function(options)
			{
				var gridView = options.gridView;
				//if (!gridView._private.globals.editHasBeenStarted)
				if (true)
				{
					var rowNumber = gridView._private.globals.currentRow;
					if (rowNumber != null && rowNumber != -1)
					{
						var row = gridView._private.functions.getRowByRowNumber({gridView: gridView, rowNumber: rowNumber});
						if (row != null)
						{
							//row.dom.addClass('currentRow');
							row.dom.addClass('waf-state-active');
						}
					}
				}		
			},

			hideCurrentRow: function(options)
			{
				var gridView = options.gridView;
				//$('.currentRow',gridView._private.globals.targetNode).removeClass('currentRow');
				$('.waf-dataGrid-row.waf-state-active',gridView._private.globals.targetNode).removeClass('waf-state-active');
			},

			// redraws rows so that they will be placed inside visible area of the viewport
			updateRowPositions: function(options)
			{

				var gridView = options.gridView;

				// if grid is already being populated, call this function again later
				if (gridView._private.globals.currentlyUpdatingRowPositions)
				{
					window.setTimeout(function() {gridView._private.functions.updateRowPositions(options)}, 100);
					return false;
				} else
				{
					gridView._private.globals.currentlyUpdatingRowPositions = true;
				}

				// get viewport top scroll position. For mobile, can not use scrollTop()
                var viewportTop = -(gridView._private.globals.viewportContainerNode.position().top); 

				// calculate what's the first row position, as well as internal position inside .rows array
				// include cache size offset
				var firstVisibleRowPosition = Math.floor(viewportTop / gridView._private.globals.rowHeight) - gridView._private.globals.cacheSizeInRows;

				// make sure cache offset doesn't go behind existing row numbers
				firstVisibleRowPosition = (firstVisibleRowPosition >= 0) ? firstVisibleRowPosition : 0;

				// calculate internal position inside .rows array
				var firstVisibleRowInternalId = firstVisibleRowPosition % gridView._private.globals.rows.length;


				// calculate what's the last row position, as well as internal position inside .rows array
				var lastVisibleRowPosition = firstVisibleRowPosition + gridView._private.globals.rows.length - 1;

				// make sure cache offset doesn't go behind above row numbers
				lastVisibleRowPosition = (lastVisibleRowPosition <= gridView._private.globals.totalRowCount) ? lastVisibleRowPosition : gridView._private.globals.totalRowCount;

				// calculate internal position inside .rows array			
				var lastVisibleRowInternalId = lastVisibleRowPosition % gridView._private.globals.rows.length;


				// check if first and last visible rows should currently be visible
				if ((gridView._private.globals.rows[firstVisibleRowInternalId].rowNumber !== firstVisibleRowPosition) ||
					(gridView._private.globals.rows[lastVisibleRowInternalId].rowNumber !== lastVisibleRowPosition))
				{

					// it's not, reposition rows
					for (var rowCount = 0; rowCount < gridView._private.globals.rows.length; rowCount++)
					{

						// what's the row position inside .rows array?
						var internalRowId = ((firstVisibleRowInternalId + rowCount) < gridView._private.globals.rows.length) ?
							(firstVisibleRowInternalId + rowCount) : (rowCount - (gridView._private.globals.rows.length - firstVisibleRowInternalId));

						// calculate row positions
						var currentRow = gridView._private.globals.rows[internalRowId];
						var currentRowPosition = firstVisibleRowPosition + rowCount;
						var currentRowNumber = currentRow.rowNumber;

						// check if current row position matches what position should be
						if (currentRowNumber !== currentRowPosition)
						{

							// row position didn't match, move it to right location
							var rowCSSTop = ((currentRowPosition * gridView._private.globals.rowHeight) -
								(internalRowId * gridView._private.globals.rowHeight));

							// set row contents to blank
							for (var cellCount = 0; cellCount < currentRow.cells.length; cellCount++)
							{
								currentRow.cells[cellCount].insideCell.html(gridView._private.globals.cellNeedsUpdateHTMLContent);
							}

							currentRow.rowNumber = currentRowPosition;
							currentRow.needsDataUpdate = true;
							currentRow.dom.css('top', rowCSSTop + 'px');

						}
					}


				}

				gridView._private.globals.currentlyUpdatingRowPositions = false;

			},

			// go through the visible rows and request data from controller
			updateVisibleRowData: function(options)
			{

				var gridView = options.gridView;

				if (false)
				{
					// clear existing events
					window.clearTimeout(gridView._private.globals.rowContentUpdateDelayEvent);
					gridView._private.globals.rowContentUpdateDelayEvent = null;

					// if event wasn't delayed, delay it and call this function again
					if (!options.isDelayedForCache)
					{

						// call delay on update
						var delayOptions = options;
						delayOptions.isDelayedForCache = true;

						gridView._private.globals.rowContentUpdateDelayEvent = window.setTimeout(function()
						{
							gridView._private.functions.updateVisibleRowData(delayOptions);
						}, 20);

						return;

					}

					// calculate internal position inside .rows array
					var firstVisibleRowInternalId = firstVisibleRowPosition % gridView._private.globals.rows.length;

					for (var rowCount = firstVisibleRowInternalId; rowCount < gridView._private.globals.rows.length; rowCount++)
					{
						var row = gridView._private.globals.rows[rowCount];
						if (row.needsDataUpdate)
						{
							//row.dom.removeClass('waf-state-hover');
							if (!!gridView.gridController)
							{
								if (!!gridView.gridController.setContentForRow)
								{
									if (gridView.gridController.isContentAvailableForRow(row.rowNumber))
									{
										gridView._private.functions.setRowContents({
											contents: gridView.gridController.setContentForRow(row.rowNumber),
											rowNumber: row.rowNumber,
											gridView: gridView
										});

										row.style = gridView.gridController.setStyleForRow(row.rowNumber).rowStyle;

										if (row.style != row.oldStyle)
										{
											row.dom.addClass(row.style);

											row.dom.removeClass(row.oldStyle);
											row.oldStyle = row.style;
										}

										row.needsDataUpdate = false;
									}
								}
							}
						}
					}

					for (var rowCount = 0; rowCount < firstVisibleRowInternalId; rowCount++)
					{
						var row = gridView._private.globals.rows[rowCount];
						if (row.needsDataUpdate)
						{
							//row.dom.removeClass('waf-state-hover');
							if (!!gridView.gridController)
							{
								if (!!gridView.gridController.setContentForRow)
								{
									if (gridView.gridController.isContentAvailableForRow(row.rowNumber))
									{
										gridView.gridController.setContentForRow(row.rowNumber);
										row.needsDataUpdate = false;
									}
								}
							}
						}
					}
				}

				// check if delay is enabled
				if (gridView._private.globals.rowContentUpdateDelayInMs !== 0)
				{

					// clear existing events
					window.clearTimeout(gridView._private.globals.rowContentUpdateDelayEvent);
					gridView._private.globals.rowContentUpdateDelayEvent = null;

					// if event wasn't delayed, delay it and call this function again
					if (!options.isDelayed)
					{

						// call delay on update
						var delayOptions = options;
						delayOptions.isDelayed = true;

						gridView._private.globals.rowContentUpdateDelayEvent =
							window.setTimeout(function() {gridView._private.functions.updateVisibleRowData(delayOptions);},
							gridView._private.globals.rowContentUpdateDelayInMs);

						return;

					}
				}

				// get viewport top scroll position
				//var viewportTop = gridView._private.globals.viewportNode.scrollTop();
				var viewportTop = -(gridView._private.globals.viewportContainerNode.position().top);

				// calculate what's the first row position, as well as internal position inside .rows array
				// include cache size offset
				var firstVisibleRowPosition = Math.floor(viewportTop / gridView._private.globals.rowHeight);

				// make sure cache offset doesn't go behind existing row numbers
				firstVisibleRowPosition = (firstVisibleRowPosition >= 0) ? firstVisibleRowPosition : 0;

				// calculate internal position inside .rows array
				var firstVisibleRowInternalId = firstVisibleRowPosition % gridView._private.globals.rows.length;

				for (var rowCount = firstVisibleRowInternalId; rowCount < gridView._private.globals.rows.length; rowCount++)
				{
					var row = gridView._private.globals.rows[rowCount];
					if (row.needsDataUpdate)
					{
						//row.dom.removeClass('waf-state-hover');
						if (!!gridView.gridController)
						{
							if (!!gridView.gridController.setContentForRow)
							{
								gridView._private.functions.setRowContents({
									contents: gridView.gridController.setContentForRow(row.rowNumber),
									rowNumber: row.rowNumber,
									gridView: gridView
								});

								row.style = gridView.gridController.setStyleForRow(row.rowNumber).rowStyle;

								if (row.style != row.oldStyle)
								{
									row.dom.addClass(row.style);

									row.dom.removeClass(row.oldStyle);
									row.oldStyle = row.style;
								}

								row.needsDataUpdate = false;
							}
						}
					}
				}
				for (var rowCount = 0; rowCount < firstVisibleRowInternalId; rowCount++)
				{
					var row = gridView._private.globals.rows[rowCount];
					if (row.needsDataUpdate)
					{
						//row.dom.removeClass('waf-state-hover');
						if (!!gridView.gridController)
						{
							if (!!gridView.gridController.setContentForRow)
							{
								gridView.gridController.setContentForRow(row.rowNumber);
								gridView._private.functions.setRowContents({
									contents: gridView.gridController.setContentForRow(row.rowNumber),
									rowNumber: row.rowNumber,
									gridView: gridView
								});

								row.style = gridView.gridController.setStyleForRow(row.rowNumber).rowStyle;

								if (row.style != row.oldStyle)
								{
									row.dom.addClass(row.style);

									row.dom.removeClass(row.oldStyle);
									row.oldStyle = row.style;
								}

								row.needsDataUpdate = false;
							}
						}
					}
				}

			},

			// sets row contents based on the array
			setRowContents: function(options)
			{

				var gridView = options.gridView;

				var contents = options.contents;
				var rowNumber = options.rowNumber;

				// if no contents are passed, skip adding contents
				if (!contents)
					return;

				// get row by row number, to make sure that we're setting contents for visible rows
				var row = gridView._private.functions.getRowByRowNumber({gridView: gridView, rowNumber: rowNumber});

				if (!!row)
				{
					// cycle through cells and set contents
					for (var cellCount = 0; cellCount < row.cells.length; cellCount++)
					{
						var cell = row.cells[cellCount];

						cell.insideCell.html(contents[cellCount]);
						// }
					}
				}
				else
				{
					var gdebug = ""; // break here
				}

			},

			// gets row by row number
			getRowByRowNumber: function(options)
			{ 

				var gridView = options.gridView;

				var rowNumber = options.rowNumber;

				// find row by row number
				for (var rowCount = 0; rowCount < gridView._private.globals.rows.length; rowCount++)
				{
					var row = gridView._private.globals.rows[rowCount];
					if (row.rowNumber === rowNumber)
					{
						return row;
					}
				}

				return null;

			},
			
			// row click event
			onRowClick: function(event)
			{
				var gridView = event.data.gridView; 				
				var row = event.data.row;
				
				if (!gridView._private.globals.containerMoved) {
				    
				    gridView._private.globals.rowClicked = true;

    				if (gridView.currentEditingRow() != row.rowNumber)
    				{ 
    				    if( gridView._private.editParams ) {
        				    gridView._private.functions.endEditCell(gridView._private.editParams);
        				}
    					//gridView._private.functions.endEditCell({gridView: gridView});
    					gridView.gridController.dataGrid.dataSource.select(row.rowNumber, { onSuccess: function(event)
    					{
    						if (!!gridView.gridController.onRowClick)
    						{
    							gridView.gridController.onRowClick(row.rowNumber);
    						}
    					} });

    				}
				}else{
				    gridView._private.globals.containerMoved = false;
				}
				
				
				return true;
			},
			
			onCellDblClick: function(event)
			{ 
	
				var gridView = event.data.gridView;    
  		        //var tend = new Date().getTime(); /* add time calculation MOD */
                var lastTouch = gridView._private.globals.rowTouchStart;
                gridView._private.globals.istouch = false;
                //var delta = tend - lastTouch;
                //if( delta > 500 ) {
    				gridView._private.functions.startEditCell(event.data);
                //}

			},
			
			startEditCell: function(params) 
			{
				var gridView = params.gridView;
				gridView._private.functions.endEditCell(params);
				gridView._private.editParams = params;				
				
				
				var source = gridView.gridController.dataGrid.dataSource;
				if (source != null)
				{
					source.select(params.row.rowNumber, {onSuccess: function(event)
					{
						var token = event.data;
						var gridView = token.gridView;
						var row=token.row;
						var cell = token.cell;
						var col = gridView.column(token.columnNumber+1);
						if (!col.readOnly)
						{
							cell.insideCell.hide();
							//cell.dom.removeClass('noUserSelect');
							cell.dom.addClass('editing');
							//var editArea = $('<input value="" class="inputInCell"/>');
							var editArea = $('<input name="editCellINput" type="text" value="" />');
							var sourceAtt = source.getAttribute(col.sourceAttID);
							if (sourceAtt != null)
							{
								editArea[0].value = sourceAtt.getValueForInput();
							}
							/*
							editArea.width(cell.dom.width()-2);
							*/
							editArea.height(cell.dom.height()-2);
							
							editArea.appendTo(cell.dom);
							//editArea[0].select();
							//row.dom.addClass('editingRow');
							editArea.bind('keypress', 
								{gridView: gridView, 
									row: row,
									rowNumber: row.rowNumber,
									column: col,
									cell: params.cell,
									editArea: editArea
								}, gridView._private.functions.inputKeypressHandler);
								
							editArea.bind('blur', {gridView: gridView}, gridView._private.functions.editBlurHandler);
							
							if (col.att && col.att.type == "date")
								editArea.datepicker();
							
							//editArea[0].blur();
							//document.editCellINput.focus();

							gridView._private.globals.editInfo= 
							{
								row: row,
								rowNumber: row.rowNumber,
								column: col,
								cell: params.cell,
								editArea: editArea
							};
							gridView._private.globals.editHasBeenStarted = true;
						}
					} }, params);
				}
				
			},
			
			endEditCell: function(params)
			{
				var gridView = params.gridView;
				gridView._private.editParams = null;
				gridView._private.globals.rowClicked = null;
					
				if (gridView._private.globals.editHasBeenStarted)
				{
					var editInfo = gridView._private.globals.editInfo;
					if (editInfo != null)
					{
						if (editInfo.blurTimout != null)
							window.clearTimeout(editInfo.blurTimout);
						var source = gridView.gridController.dataGrid.dataSource;
						if (source != null)
						{
							if (params.row != null && params.row.rowNumber == editInfo.rowNumber)
							{
								if (params.column != null && params.column.colID == editInfo.column.colID)
								{
									return null; // on ne termine pas l'edition quand on se trouve sur la meme cellule
								}
							}

							if (source.getPosition() == editInfo.rowNumber)
							{
								var sourceAtt = source.getAttribute(editInfo.column.sourceAttID);
								if (sourceAtt != null)
								{
									var newvalue = sourceAtt.normalize(editInfo.editArea[0].value);
									sourceAtt.setValue(newvalue);
									editInfo.cell.insideCell.html(editInfo.column.getFormattedValue(sourceAtt.getValue()));
								}
								if (params.row == null || params.row.rowNumber != source.getPosition())
									source.save();
							}
						}

						//editInfo.row.dom.removeClass('editingRow');
						editInfo.cell.dom.removeClass('editing');
						editInfo.editArea.remove();
						//editInfo.cell.dom.addClass('noUserSelect');
						editInfo.cell.insideCell.show();
						gridView._private.globals.editInfo = null;
						
					}
					gridView._private.globals.editHasBeenStarted = false;
				}
			},

			onHeaderClick: function(event)
			{

				var gridView = event.data.gridView;
				gridView._private.functions.endEditCell({gridView:gridView});
				var cell=event.data.cell;
				var columnNumber = event.data.columnNumber;

				if (!!gridView.gridController.onHeaderClick && !gridView._private.globals.resizeHasBeenStarted)
				{
					gridView.gridController.onHeaderClick(cell, columnNumber);
				}
			},
			
			startColResize: function(event)
			{
				var gridView = event.data.gridView;
				gridView._private.functions.endEditCell({gridView: gridView});
				//$(document).bind('mouseup',event.data,gridView._private.functions.endColResize);
				//$(document).bind('mousemove', event.data , gridView._private.functions.duringColResize);
				gridView._private.globals.startX = event.screenX;
				var col = gridView.column(event.data.columnNumber+1);
				gridView._private.globals.startWidth = col.width;
				gridView._private.globals.resizeHasBeenStarted = true;
				event.stopPropagation();
			},

			endColResize: function(event) 
			{
				var gridView = event.data.gridView,
                                tag = gridView.gridController.dataGrid.tag,
                                colWidth, w;

				var col = gridView.column(event.data.columnNumber+1);
				var x = event.screenX;
				var newWidth = parseInt(gridView._private.globals.startWidth) + (parseInt(x) - parseInt(gridView._private.globals.startX));
				if (newWidth < 10) {
					newWidth = 10;
                                }
				col.setWidth(newWidth);
				//$(document).unbind('mouseup', gridView._private.functions.endColResize);
				//$(document).unbind('mousemove', gridView._private.functions.duringColResize);
				gridView._private.globals.resizeHasBeenStarted = false;
				
				if (gridView.gridController.dataGrid.isInDesign)
				{
					// Saving the column width
					tag.getColumns().get(event.data.columnNumber).getAttribute('width').setValue(newWidth);

					tag.update();
					tag.domUpdate();
				}
			},
			
			duringColResize: function(event)
			{
				var gridView = event.data.gridView;
				var col = gridView.column(event.data.columnNumber+1);
                                var oldWidth = col.width;
				var x = event.screenX;
				var newWidth = parseInt(gridView._private.globals.startWidth) + (parseInt(x) - parseInt(gridView._private.globals.startX));
				if (newWidth < 10) {
					newWidth = 10;
                                }

				col.setWidth(newWidth);

                                var dif = col.width - oldWidth;

                                var gridWidth = parseInt(gridView._private.globals.headerNode.parent().css('width'));
                                var header = gridView._private.globals.headerContainerNode;
                                var containt = gridView._private.globals.viewportContainerNode;
                                
                                header.css('width', parseInt(header.css('width')) + dif + 'px');

                                containt.css('width', parseInt(containt.css('width')) + dif + 'px');
                                containt.children().css('width', parseInt(containt.css('width')) + 'px');
			},
			
			onResizeClick: function(event)
			{
				var gridView = event.data.gridView;
				gridView._private.functions.endEditCell({gridView: gridView});
				event.stopPropagation();
//				gridView._private.globals.resizeHasBeenStarted = true;
			},
			
			editBlurHandler: function(event)
			{
				var gridView = event.data.gridView;
				if (gridView._private.globals.editInfo != null)
				{
					gridView._private.globals.editInfo.blurTimout = window.setTimeout(function() 
					{ 
						if (gridView._private.globals.editInfo != null)
							gridView._private.functions.endEditCell({gridView:gridView/*, row: gridView._private.globals.editInfo.row*/});
					}, 500);
				}

				
			},
			
			inputKeypressHandler: function(event) 
			{
				var gridView = event.data.gridView;
				var row = event.data.row;
				var rowNumber = event.data.rowNumber;
				var col = event.data.column;

				var keycode = event.keyCode;
				if (keycode != null)
				{
					if (keycode == 37 || keycode == 38)
						event.shiftKey = true;
					else if (keycode == 39 || keycode == 40)
						event.shiftKey = false;
					switch(keycode) 
					{
					case 9:
					case 13:
					case 37:
					case 38:
					case 39:
					case 40:
						var colnum = col.columnNumber;
						var cols = gridView._private.globals.columns;
						var viewportNode = gridView._private.globals.viewportNode;
						var rowheight = gridView._private.globals.rowHeight;
						if (event.shiftKey)
						{
							var nextcolnum;
							var changerow = false;
							if (keycode == 38)
							{
								changerow = true;
								nextcolnum = colnum;
							}
							else
							{
								var oknext = false;
								nextcolnum = colnum-1;
								while (!oknext && nextcolnum != colnum)
								{
									if (nextcolnum < 0)
									{
										changerow = true;
										nextcolnum = cols.length-1;
									}
									if (!cols[nextcolnum].readOnly)
										oknext = true;
									else
										nextcolnum--;
								}
							}
							if (changerow)
							{
								rowNumber--;
								if (rowNumber < 0)
									row = null;
								else
								{									
									gridView._private.functions.endEditCell({gridView: gridView});
									
									var rowtop = row.dom.position().top;
									if (rowtop < rowheight*2)
									{								
										//var curtop = viewportNode.scrollTop();
										var curtop = -(gridView._private.globals.viewportContainerNode.position().top);
										curtop = curtop-rowheight;
										if (curtop < 0)
											curtop = 0;
											
										viewportNode.scrollTop(curtop);
									}
									
									row = gridView._private.functions.getRowByRowNumber({gridView: gridView, rowNumber: rowNumber});
								}
							}
							else
							{
								gridView._private.functions.endEditCell({gridView:gridView, row:row});
							}
							if (row != null)
								gridView._private.functions.startEditCell({gridView:gridView, row:row, cell:row.cells[nextcolnum], columnNumber: nextcolnum});
						}
						else
						{
							var nextcolnum;
							var changerow = false;
							if (keycode == 40)
							{
								changerow = true;
								nextcolnum = colnum;
							}
							else
							{
								var oknext = false;
								nextcolnum = colnum+1;
								while (!oknext && nextcolnum != colnum)
								{
									if (nextcolnum >= cols.length)
									{
										changerow = true;
										nextcolnum = 0;
									}
									if (!cols[nextcolnum].readOnly)
										oknext = true;
									else
										nextcolnum++;
								}
							}
							if (changerow)
							{
								rowNumber++;

								if (rowNumber >= gridView._private.globals.totalRowCount){
									//row = null;
									gridView._private.functions.endEditCell({gridView: gridView});	

                                                                        WAF.gridUtil.addRow(gridView);

									row = gridView._private.functions.getRowByRowNumber({gridView: gridView, rowNumber: rowNumber});
                                                                } else {
									gridView._private.functions.endEditCell({gridView: gridView});							
									
									var rowtop = row.dom.position().top;
									var h = viewportNode.height();
									if (rowtop + rowheight > h)
									{
										//var curtop = viewportNode.scrollTop();
										var curtop = -(gridView._private.globals.viewportContainerNode.position().top);
										curtop = curtop+ rowheight;
										viewportNode.scrollTop(curtop);
									}
									
									row = gridView._private.functions.getRowByRowNumber({gridView: gridView, rowNumber: rowNumber});
								}
							}
							else
							{
								gridView._private.functions.endEditCell({gridView:gridView, row:row});
							}
							
							if (row != null)
								gridView._private.functions.startEditCell({gridView:gridView, row:row, cell:row.cells[nextcolnum], columnNumber: nextcolnum});
						}
						
						event.preventDefault();
						event.stopPropagation();
						break;
					}
				}
			}
			

		},

		handlers: {}

	}

	/**
	* GridView.initWithOptions(options)
	* \~english 
	* @brief             Initializes the grid
	* @details           Grid is initialized with options, of which most are optional.
	* 
	* @param options : object
	* 
	* @return this : GridView
	* 
	* @code
	*  
	*  
	* @endcode    
	*/
	this.initWithOptions = function(options)
	{

		//WAF.utils.debug.console.log('[GridView] WAF.classes.GridView.initWithOptions called');

		// set reference to the grid object
		options.gridView = this;

		// initialize the grid with passed options
		this._private.functions.initWithOptions(options);

		return this;

	}

	/**
	* GridView.getPageSize()
	* \~english 
	* @brief             Number of rows per page
	* @details           Returns number of rows per page for this grid size.
	* 
	* @param none
	* 
	* @return pageSize : integer
	* 
	* @code
	*  
	*  
	* @endcode    
	*/
	this.getPageSize = function()
	{
		return this._private.globals.pageSize;
	}

	/**
	* GridView.getVisibleRowCount()
	* \~english 
	* @brief             Number of visible rows
	* @details           Returns number of visible rows on the screen.
	* 
	* @param none
	* 
	* @return visibleRowCount : integer
	* 
	* @code
	*  
	*  
	* @endcode    
	*/
	this.getVisibleRowCount = function()
	{
		return this._private.globals.visibleRowCount;
	}

	/**
	* GridView.getRowCount()
	* \~english 
	* @brief             Number of total rows
	* @details           Returns number of all rows
	* 
	* @param none
	* 
	* @return rowCount : integer
	* 
	* @code
	*  
	*  
	* @endcode    
	*/
	this.getRowCount = function()
	{
		return this._private.globals.totalRowCount;
	}

	/**
	* GridView.setRowCount()
	* \~english 
	* @brief             Sets number of total rows
	* @details           Sets number of all rows, which updates viewport height
	* 
	* @param rowCount	: integer
	* 
	* @return none
	* 
	* @code
	*  
	*  
	* @endcode    
	*/
	this.setRowCount = function(rowCount)
	{
		this._private.functions.setTotalRowCount({rowCount: rowCount, gridView: this});
	}

	/**
	* GridView.setRowContents(rowNumber, contents)
	* \~english 
	* @brief             Sets row contents
	* @details           Sets row contents with the passed array of HTML/text objects
	* 
	* @param rowNumber : integer
	* @param contents : array
	* 
	* @return none
	* 
	* @code
	*  
	*  
	* @endcode    
	*/
	this.setRowContents = function(rowNumber, contents)
	{

		this._private.functions.setRowContents({
			gridView: this,
			rowNumber: rowNumber,
			contents: contents
		});

	}

	/**
	* GridView.setRowContentUpdateRequestDelayInMs(requestDelay)
	* \~english 
	* @brief             Sets delay for row content requests in miliseconds
	* @details           To optimize performance when user is scrolling rapidly, requestDelay will be
	*						applied before row data is requested. Setting requestDelay to 0 will disable
	*						delay and requests will be called immediately
	* 
	* @param requestDelay : integer
	* 
	* @return none
	* 
	* @code
	*  
	*  
	* @endcode    
	*/
	this.setRowContentUpdateRequestDelayInMs = function(requestDelay)
	{

	}

	/**
	* GridView.refresh()
	* \~english 
	* @brief             Refreshes grid data
	* @details           Requests again data for the grid, updates row number
	* 
	* @param none
	* 
	* @return none
	* 
	* @code
	*  
	*  
	* @endcode    
	*/
	this.refresh = function()
	{
		this._private.functions.refresh({gridView: this});
	}

	/**
	* 
	* @param {Object} html
	*/
	this.setStatusRight = function(html)
	{
		this._private.globals.statusRightContainer.html(html);
	}

	this.resetSortIndicator = function()
	{
		var containerNode = this._private.globals.headerContainerNode;
		for(var i = 0, max = this._private.globals.columns.length; i < max; ++i) {
			containerNode.cells[ i ].sortIndicator.removeClass("waf-sort-asc waf-sort-desc");
		}
	}

	this.setSortIndicator = function(columnNb, sortOrder)
	{
		//this._private.globals.headerContainerNode.cells[columnNb].sortIndicator.removeClass("waf-sort-asc waf-sort-desc").addClass('waf-sort-' + sortOrder);
		this.resetSortIndicator();
		if(columnNb !== null && columnNb >= 0 && columnNb < this._private.globals.columns.length) {
			var theCol = this._private.globals.headerContainerNode.cells[columnNb].sortIndicator.removeClass("waf-sort-asc waf-sort-desc");
			sortOrder = sortOrder || 'asc';
			if(sortOrder !== 'asc' && sortOrder !== 'desc') {
				sortOrder = 'asc';
			}
			theCol.addClass('waf-sort-' + sortOrder);
		}
	}

	// constructor	
	this.gridController = null;

	this.kill = function()
	{
		$(this._private.globals.targetNode).html("");
	}

	this.column = function(colRef, colSettings)
	{
		var result = null;
		if (typeof colRef == "string")
		{
			result = this._private.globals.colsByID[colRef];
		}
		else
		{
			if (colRef > 0 && colRef <= this._private.globals.columns.length)
			{
				result = this._private.globals.columns[colRef-1];
			}
		}
		if (result != null && colSettings != null && typeof colSettings == "object")
		{
			for (prop in colSettings)
			{
				switch(prop) {
					case "textSize":
						result.setTextSize(colSettings[prop]);
						break;
					case "color":
						result.setColor(colSettings[prop]);
						break;
					case "backgroundColor":
						result.setBackgroundColor(colSettings[prop]);
						break;
					case "width":
						result.setWidth(colSettings[prop]);
						break;
					case "format":
						result.setFormat(colSettings[prop]);
						break;
					case "renderer":
						result.setRenderer(colSettings[prop]);
						break;
				}
			}
		}
		return result;
	}
	
	this.columns = function(colSettings)
	{
		return this._private.globals.columns;
	}
	
	this.currentEditingRow = function()
	{
		var result = -1;
		if (this._private.globals.editHasBeenStarted)
		{
			var editInfo = this._private.globals.editInfo;
			if (editInfo != null)
			{
				result = editInfo.rowNumber;
			}
		}
		return result;
	}
	
	this.updateCell = function(rowNumber, attName, value)
	{ 
		var col = this.column(attName);
		if (col != null)
		{
			var colnum = col.columnNumber;
			var row = this._private.functions.getRowByRowNumber({gridView: this, rowNumber: rowNumber});
			if (row != null)
			{
				var cell = row.cells[colnum];
				if (cell != null)
				{
					var content = "";
					if (col.renderer != null)
					{
						content = col.renderer({ value: value, rowNumber:rowNumber, dataSource:this.gridController.dataGrid.dataSource, cellDiv: cell.insideCell});
					}
					else
						content = col.getFormattedValue(value);
					cell.insideCell.html(content);
				}
			}
		}
	}
	
	this.setCurrentRow = function(rowNumber)
	{
		var gridvars = this._private.globals;
		this._private.functions.hideCurrentRow({gridView: this});
		gridvars.currentRow = rowNumber;
		this._private.functions.showCurrentRow({gridView: this});
		if (gridvars.options.autoScrollOnSelected)
		{
			this.centerRow(rowNumber, { doNotScrollIfVisible : true});
		}
	}
	
	this.centerRow = function(rowNumber, options)
	{
		options = options || {};
		if (typeof rowNumber != 'number')
			rowNumber = 0;
		var gridView = this;
		var gridvars = this._private.globals;
		var gridfuncs = this._private.functions;
		
		var totalRows = gridvars.totalRowCount;
		var nbRowsInPage = Math.round(gridvars.viewportNode.height() / gridvars.rowHeight);

		if (rowNumber < 0)
			rowNumber = 0;
		if (rowNumber >= totalRows)
			rowNumber = totalRows - 1;
		
		var mustScroll = true;
		if (options.doNotScrollIfVisible)
		{
			var nbFullRowsInPage = Math.floor(gridvars.viewportNode.height() / gridvars.rowHeight);
			var actualTop = -(gridvars.viewportContainerNode.position().top) / gridvars.rowHeight;
			if (rowNumber >= actualTop && rowNumber < Math.floor(actualTop)+nbFullRowsInPage)
			{
				mustScroll = false;
			}
			
		}	
		
		if (mustScroll)
		{
			var toprow = rowNumber - Math.floor(nbRowsInPage/2);
			if (toprow < 0)
				toprow = 0;
			//use scrollTo, method of iScroll lib
			gridView._private.scrollObject.scrollTo( 0, -(toprow * gridvars.rowHeight));
			
		}
	}
	
	this.setOptions = function(options)
	{
		if (options != null)
		{
			if (options.autoScrollOnSelected != null)
			{
				var gridvars = this._private.globals;
				gridvars.options.autoScrollOnSelected = options.autoScrollOnSelected;
			}
		}
	}


	return this;
};



WAF.classes.GridColumn =
{
	setTextSize: function(textSize)
	{
		this.textSize = textSize;
		//$(".cellCol"+this.columnNumber, this.gridview._private.globals.targetNode).css("font-size", ""+textSize+"px");
		$(".waf-dataGrid-col-"+this.colID, this.gridview._private.globals.targetNode).css("font-size", ""+textSize+"px");
	},
	
	setColor: function(color)
	{
		this.color = color;
		//$(".cellCol"+this.columnNumber, this.gridview._private.globals.targetNode).css("color", color);
		$(".waf-dataGrid-col-"+this.colID, this.gridview._private.globals.targetNode).css("color", color);
	},

	setBackgroundColor: function(backColor)
	{
		this.backColor = backColor;
		//$(".cellCol"+this.columnNumber, this.gridview._private.globals.targetNode).css("background-color", backColor);
		$(".waf-dataGrid-col-"+this.colID, this.gridview._private.globals.targetNode).css("background-color", backColor);
	},

	setWidth: function(colWidth)
	{
		this.width = colWidth;
		//$(".cellCol"+this.columnNumber, this.gridview._private.globals.targetNode).width(colWidth);
		//$(".headerCellCol"+this.columnNumber, this.gridview._private.globals.targetNode).width(colWidth);
		$(".waf-dataGrid-col-"+this.colID, this.gridview._private.globals.targetNode).width(colWidth);
		if (this.renderer != null)
			this.gridview.gridController.dataGrid.redraw();
	},
	
	setFormat: function(format)
	{
		if (typeof(format) == "string")
			format = { format:format };
		this.format = format;
		this.gridview.gridController.dataGrid.redraw();
		
	},
	
	setRenderer: function(renderer)
	{
		this.renderer = renderer;
		this.gridview.gridController.dataGrid.redraw();
	}


	
};



WAF.gridUtil.addRow = function(gridView) 
{ 
	var source = gridView.gridController.dataGrid.dataSource;
	if (source != null)
	{
            source.addNewElement();
			
			
    		window.setTimeout(function(){
		    
    		    var row = gridView._private.functions.getRowByRowNumber({gridView: gridView, rowNumber: gridView._private.globals.totalRowCount-1});
    		    gridView._private.functions.startEditCell({
                    gridView : gridView,
                    columnNumber : 0,
                    row : row,
                    cell : row.cells[0]
                });
		    
    		}, 0);
			
			/*
            // Focus on the first column
            var row = gridView._private.globals.rows[(gridView._private.globals.rows.length-1)];

            var cellWidth = gridView._private.globals.columns[0].width;
            var cellStyle = gridView._private.globals.columns[0].style;

            var cell = {
                dom: $('<div class="waf-dataGrid-cell col-0"></div>').addClass(cellStyle).appendTo(row.dom)
            }
            cell.insideCell = $('<div class="content"></div>').appendTo(cell.dom);

            try {
                cell.dom.width(cellWidth - parseInt(cell.dom.css('border-left-width')) - parseInt(cell.dom.css('border-right-width')) - parseInt(cell.dom.css('padding-left')) - parseInt(cell.dom.css('padding-right')) - parseInt(cell.dom.css('margin-left')) - parseInt(cell.dom.css('margin-right')))
            } catch(e) {
                cell.dom.width(cellWidth);
            }

            try {
                cell.dom.height(gridView._private.globals.rowHeight - parseInt(row.dom.css('border-bottom-width')) - parseInt(row.dom.css('border-top-width')) - parseInt(row.dom.css('padding-bottom')) - parseInt(row.dom.css('padding-top')) - parseInt(row.dom.css('margin-bottom')) - parseInt(row.dom.css('margin-top')) - parseInt(cell.dom.css('border-bottom-width')) - parseInt(cell.dom.css('border-top-width')) - parseInt(cell.dom.css('padding-bottom')) - parseInt(cell.dom.css('padding-top')) - parseInt(cell.dom.css('margin-bottom')) - parseInt(cell.dom.css('margin-top')));
            } catch(e) {
                cell.dom.height(gridView._private.globals.rowHeight);
            }

            row.cells.push(cell);
            */


				
	}
}


WAF.gridUtil.delRow = function(gridView) 
{
	var source = gridView.gridController.dataGrid.dataSource;
	if (source != null)
	{
		source.removeCurrent();
	}
}






/**
 * ----------------------------------------------------------------------------
 * content of widget-dataGrid-controller.js
 * ----------------------------------------------------------------------------
 */

/**
 * @brief			GridController, part of WAF/UI/Grid
 * @details			Collection of functions that are called by GridView. Use this code to link
 a view (in this case GridView) to your data model in order to achieve Model-View-Controller (MVC))
 architecture.
 * 
 * 
 *  
 * @author			rudolfpsenicnik
 * @date			February 2009 
 * @version			1.0
 * 
 * @include			copyright.txt
 */

WAF.classes.GridController = function() {

 	// Private
	this._private = {
		globals		: {

		},
		functions	: {
			
		},
		handlers	: {
			
		}
	};
	
	/**
	* GridController.getColumnCount(grid)
	* \~english 
	* @brief             Sets grid column count
	* @details           Return column count for the grid, usually called when grid is initialized
	* 
	* @param grid : GridView
	* 
	* @return columnCount : integer
	* 
	* @code
	*  
	*  
	* @endcode    
	*/	
	this.getColumnCount = function (grid) {
	
		var columnCount = 0;
	
		return columnCount;
	
	}

	/**
	* GridController.getRowCount(grid)
	* \~english 
	* @brief             Sets grid row count
	* @details           Return number of rows, usually called when grid is initialized
	This will update viewport height, and only rows that are visible will be rendered
	* 
	* @param grid : GridView
	* 
	* @return rowCount : integer
	* 
	* @code
	*  
	*  
	* @endcode    
	*/	
	this.getRowCount = function (grid) {
	
		var rowCount = 0;
	
		return rowCount;
	
	}

	/**
	* GridController.setContentForRow(grid)
	* \~english 
	* @brief             Sets row contents
	* @details           Row contents are set based on the passed array of HTML/text elements
	Returning array with length 0 will NOT erase existing contents, to do that, pass empty array.
	* 
	* @param rowNumber : integer
	* 
	* @return contents : array
	* 
	* @code
	*  
	*  
	* @endcode    
	*/	
	this.setContentForRow = function (rowNumber) {
	
		var contents = [ ];
	
		return contents;
	
	}
	
	this.isContentAvailableForRow = function (rowNumber) {
		
		return true;
		
	}

	this.setStyleForRow = function (rowNumber) {
		
		return { rowStyle: '' };
		
	}

	this.setPropertiesForColumn = function (columnProperties) {
	
		return {};
	
	}
	
	this.onRowClick = function (rowNumber) {
	
		//WAF.utils.debug.console.log("Clicked on row " + rowNumber);
	
	}
	
	this.onHeaderClick = function (cell,columnNumber) {
	
		
	
	}
	
	// constructor
	this.gridView = new WAF.classes.GridView();
	this.gridView.gridController = this;
};







/**
 * ----------------------------------------------------------------------------
 * original content of widget-dataGrid.js
 * ----------------------------------------------------------------------------
 */

WAF.widget.Grid = function (params) {
    // check if dataSource
    if (!params.inDesign && !WAF.source[params.dataSource]) {
        return {};
    }
	
    params.colNames = params.colNames ? params.colNames.split(",") : null;
    params.colAttributes = params.colAttributes ? params.colAttributes.split(",") : null;

    var grid = null;
	
	
    var options = {
        //dataStore       : entityCollection,
        columns         : params.columns || null,
        colNames        : params.colNames,
        colAttributes   : params.colAttributes,
        colWidth        : params.colWidth,
        parentNode      : params.id,
        cacheSize       : 0, //0.5,
        rowHeight       : 50,
        dataSource      : WAF.source[params.dataSource],
        subscriberID    : params.id,
        inDesign        : params.inDesign,
        cls             : params.cls,
		included		: params.included
    }

    grid = new WAF.classes.DataGrid(options);

    // add type
    grid.kind = 'datagrid';
    
    WAF.grids[params.id] = grid;
    WAF.widgets[params.id] = grid;

    return grid;

};
